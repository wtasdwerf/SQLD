헷갈리는 Keyword

1차 정규화 

2차 정규화

3차 정규화

1:1

1:M

1:N

개별 테이블

개별로 발생되는 

트랜젝션

슈퍼 타입 데이터 모델 / 서브 타입 데이터 모델

업무를 구성하는 데이터의 공통점과 차이점의 특징을 고려하여 효과적으로 표현하는 논리적인 모델이다

공통의 부분을 슈퍼타입으로 모델링하고, 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성에 대해서는 별도로 서브엔터티로 구분하여 업무의 모습을 정확하게 표현하면서, 물리적인 데이터 모델로 변환을 할 때 선택의 폭을 넓힐수 있는 장점이 있다.


37. 

칼럽에 의한 반복적인 속성 값을 갖는 형태는 속성의 원자성을 위배한 제 1차 정규화 대상이 된다. 이와같은 반복적인 속성 나열 형태에서는 각 속성에 대해 'or' 연산자로 연결된 조건들이 사용되는데, 이때 어느 하나의 속성이라도 인덱스가 정의되어 있지 않게 되면 'or'로 연결된 모든 조건절들이 인덱스를 사용하지 않고 한번의 전체 데이터 스캔으로 처리되게 되어 성능 저하가 나타날 수 있게 되며, 또한 모든 반복 속성에 인덱스를 생성하게 되면 검색 속도는 좋아지겠지만 반대급부적으로 너무 많은 인덱스로 인해 입력, 수정, 삭제의 성능이 저하되므로, 1차 정규화를 통해서 자연스럽게 문제가 해결될 수 있도록 해야 한다.

40. 

다음 중 데이터 모델에 대한 반정규화를 고려할때 판단 요소에 대한 설명을 가장 적절한 것은?

정답 = 반정규화 정보에 대한 재현의 적시성으로 판단한다. 예를 들어 빌링의 잔액(balance)은 다수 테이블에 대한 다량의 조인이 불가피하므로 데이터 제공의 적시성 확보를 위한 필수 반정규화 대상 정보이다.

해설 =

- 다량 데이터 탐색의 경우 인덱스가 아닌 파티션 및 데이터 클러스터링 등의 다양한 물리 저장 기법을 활용하여 성능 개선을 유도할 수 있다. 다만, 하나의 결과셋을 추출하기 위해 다량의 데이터를 탐색하는 처리가 반복적으로 빈번하게 발생한다면 이때문 반정규화를 고려하는 것이 좋다.

- 이전 또는 이후 위치의 레코드에 대한 탐색은 window function으로 접근 가능하다.

- 집계 테이블 이외에도 다양한 유형 ( 다수 테이블의 키 연결 테이블 등 )에 대하여 반정규화 테이블 적용이 필요할 수 있다.

46.

하나의 테이블에 많은 양의 데이터가 저장되면 인덱스를 추가하고 테이블을 몇개로 쪼개도 성능이 저하되는 경우가 있다. 이때 논리적으로는 하나의 테이블이지만 물리적으로는 여러개의 테이블로 분리하여 데이터 액세스 성능도 향상시키고, 데이터 관리방법도 개선할 수 있도록 테이블에 적용하는 기법을

파티셔닝

이라고 한다

51.

엔터티간에 논리적 관계가 있을 경우, 즉 엔터티 간에 관계(Relationship)을 정의하여 관련 엔터티 상호간에 업무적인 연관성이 있을을 표현한 경우에는, 이 데이터들이 업무적으로 밀접하게 연결되어 상호간에 조인이 자주 발생한다는 것을 의미하는 것이기 때문에, 데이터베이스 상에서 DBMS가 제공하는 FK Constraints를 생성했는지 여부와 상관없이 조인 성능을 향상시키기 위한 인덱스를 생성해주는 것이 좋다.

데이터베이스에 생성하는 FK Constraints는 데이터 모델 상에 표현된 논리적 관계에 따라 관련 인스턴스 간에 일관성을 보장하기 위해 설계된 제약 조건을 구현할 수 있도록  DBMS가 제공해주는 하나의 '지원 기능' 으로 이해될 수 있다.

